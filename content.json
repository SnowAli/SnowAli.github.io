{"meta":{"title":"SnowAli","subtitle":"","description":"","author":"SnowAli","url":"http://example.com","root":"/"},"pages":[{"title":"tags","date":"2020-10-11T06:15:57.000Z","updated":"2020-10-18T03:37:38.428Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2020-10-18T03:34:25.000Z","updated":"2020-10-18T03:37:31.536Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-10-18T03:33:48.000Z","updated":"2020-10-18T03:35:07.770Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Node.js路由","slug":"node.js路由","date":"2020-10-11T07:54:26.000Z","updated":"2020-10-22T03:43:31.256Z","comments":true,"path":"2020/10/11/node.js路由/","link":"","permalink":"http://example.com/2020/10/11/node.js%E8%B7%AF%E7%94%B1/","excerpt":"Node.js路由路由: Web服务器根据用户输入的不同url返回不同的页面。","text":"Node.js路由路由: Web服务器根据用户输入的不同url返回不同的页面。 例如登录页面login和注册页面register 123#默认端口都为80http:&#x2F;&#x2F;localhost:80&#x2F;loginhttp:&#x2F;&#x2F;localhost:80&#x2F;register 实现思路建立所需要的文件, index.js文件作为入口文件, router.js实现路由响应, server.js用来处理请求. file文件夹下就建立几个不同的页面, 展示路由跳转. 创建一个http服务器，用于监听用户输入的request参数, 获取request.url12345678&#x2F;&#x2F; server.jsconst http &#x3D; require(&quot;http&quot;);http.createServer(onRequest).listen(&#39;8888&#39;);function onRequest(req, res) &#123; &#x2F;&#x2F; onRequest处理用户请求 console.log(req.url);&#125; 解析url，得到具体的请求页面，也就是路由入口12345678910&#x2F;&#x2F; server.jsconst url &#x3D; require(&quot;url&quot;);function onRequest(req, res) &#123; console.log(req.url); let myUrl &#x3D; url.parse(req.url); console.log(myUrl);&#125; 根据url渲染不同页面123456789101112131415161718192021222324252627282930const http &#x3D; require(&quot;http&quot;);const fs &#x3D; require(&quot;fs&quot;);let Response &#x3D; function(res, filePath) &#123; fs.readFile(filePath, (err, data) &#x3D;&gt; &#123; if(err) &#123; res.writeHead(404, &#123; &quot;Content-Type&quot;: &quot;text&#x2F;html&quot; &#125;); res.end(&quot;error&quot;) &#125; else &#123; res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text&#x2F;html&quot; &#125;); res.end(data); &#125; &#125;)&#125;let router &#x3D; function(req, res) &#123; if(req.url &#x3D;&#x3D; &#39;&#x2F;index&#39; || req.url &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123; &#x2F;&#x2F;主页 index.index(res); &#125; else if(req.url &#x3D;&#x3D; &#39;&#x2F;poem&#39;) &#123; &#x2F;&#x2F; 古诗页面 Response(res, poem); &#125; else &#123; &#x2F;&#x2F; 不存在的页面 Response(res, error); &#125;&#125; 以上几步就能做一个简单的node路由demo了, 下面贴上完整的代码:12345&#x2F;&#x2F; 入口文件&#x2F;&#x2F; index.jsvar server &#x3D; require(&quot;.&#x2F;server&quot;);server.start(); 123456789101112131415161718192021222324252627282930313233343536373839404142&#x2F;&#x2F; router.js&#x2F;&#x2F; 需响应的文件路由const http &#x3D; require(&quot;http&quot;);&#x2F;&#x2F; 导入文件系统模块&#x2F;&#x2F; 所有的文件系统操作都具有同步的、回调的、以及基于 promise 的形式。const fs &#x3D; require(&quot;fs&quot;);const index &#x3D; require(&quot;.&#x2F;file&#x2F;index&quot;); &#x2F;&#x2F; 主页路由模块const error &#x3D; &quot;.&#x2F;file&#x2F;error404.html&quot;; &#x2F;&#x2F; 错误处理路由const poem &#x3D; &quot;.&#x2F;file&#x2F;poem.html&quot;; &#x2F;&#x2F; 古诗路由let Response &#x3D; function(res, filePath) &#123; fs.readFile(filePath, (err, data) &#x3D;&gt; &#123; if(err) &#123; res.writeHead(404, &#123; &quot;Content-Type&quot;: &quot;text&#x2F;html&quot; &#125;); res.end(&quot;error&quot;) &#125; else &#123; res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text&#x2F;html&quot; &#125;); res.end(data); &#125; &#125;)&#125;let router &#x3D; function(req, res) &#123; if(req.url &#x3D;&#x3D; &#39;&#x2F;index&#39; || req.url &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123; &#x2F;&#x2F;主页 index.index(res); &#125; else if(req.url &#x3D;&#x3D; &#39;&#x2F;poem&#39;) &#123; Response(res, poem); &#125; else &#123; Response(res, error); &#125;&#125;exports.router &#x3D; router; 123456789101112131415161718192021222324252627282930313233343536373839&#x2F;&#x2F; server.js&#x2F;&#x2F; 服务端的start函数, 用于开启一个web服务器&#x2F;&#x2F; 导入http模块，使用HTTP服务器和客户端&#x2F;&#x2F; Node中的HTTP API是非常底层的，&#x2F;&#x2F; 仅进行流处理和消息解析。它将消息解析为消息头和消息体，但不会解析具体的消息头或消息体const http &#x3D; require(&quot;http&quot;);&#x2F;&#x2F; 导入url模块，用于处理与解析 URL。&#x2F;&#x2F; URL字符串是结构化的字符串，包含多个含义不同的组成部分。解析后返回的是URL对象&#x2F;&#x2F; url 模块提供了两套 API 来处理 URL：一个是旧版本传统的 API，一个是实现了 WHATWG标准的新 API。const url &#x3D; require(&quot;url&quot;);const router &#x3D; require(&#39;.&#x2F;router&#39;)function start() &#123; function onRequest(req, res) &#123; if(req.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;favicon.ico&#39;) &#123; &#x2F;&#x2F; 浏览器默认会请求网站根目录的favicon.ico图标，如果网站根目录没有会产生 404。出于优化的考虑，要么就有这个图标，要么就禁止产生这个请求。 return ; &#125; console.log(&#39;End of line&#39;); console.log(req.url); let myUrl &#x3D; url.parse(req.url); console.log(myUrl); router.router(req, res) &#125; http.createServer(onRequest).listen(&#39;8888&#39;) console.log(&quot;Server is running at &quot; + &quot;http:&#x2F;&#x2F;localhost:8888&quot;);&#125;exports.start &#x3D; start;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-10-11T06:58:02.426Z","updated":"2020-10-11T07:36:14.253Z","comments":true,"path":"2020/10/11/hello-world/","link":"","permalink":"http://example.com/2020/10/11/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}