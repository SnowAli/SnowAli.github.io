{"meta":{"title":"SnowAli","subtitle":"","description":"","author":"SnowAli","url":"http://example.com","root":"/"},"pages":[{"title":"tags","date":"2020-10-11T06:15:57.000Z","updated":"2020-10-18T03:37:38.428Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2020-10-18T03:34:25.000Z","updated":"2020-10-18T03:37:31.536Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-10-18T03:33:48.000Z","updated":"2020-10-18T03:35:07.770Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Babel转码器","slug":"Babel转码","date":"2020-10-28T15:05:52.866Z","updated":"2020-10-28T15:08:27.173Z","comments":true,"path":"2020/10/28/Babel转码/","link":"","permalink":"http://example.com/2020/10/28/Babel%E8%BD%AC%E7%A0%81/","excerpt":"1.6 Babel转码器Babel(babeljs.io/) 是一个广泛使用的ES6转码器，可以将ES6代码转化为ES5代码，从而在浏览器或其他环境执行。","text":"1.6 Babel转码器Babel(babeljs.io/) 是一个广泛使用的ES6转码器，可以将ES6代码转化为ES5代码，从而在浏览器或其他环境执行。 1.6.1 配置文件 .babelrc存放在根目录下的配置文件，用来设置转码规则和插件： 12345678&#123; &quot;presets&quot;: [ &quot;latest&quot;, &quot;react&quot;, &quot;stage-2&quot; ], &quot;plugins&quot;: []&#125; 要想使用Babel工具和模块，必须先写好.babelrc。 1.6.2 命令行转码 babel-cli1.6.3 babel-nodebabel-cli工具自带的一个babel-node命令，提供一个支持ES6的REPL环境，可以直接运行ES6代码。babel-node命令可以直接运行ES6脚本： 123456789&#x2F;&#x2F; 安装babel-clinpm install --save-dev babel-cli&#x2F;&#x2F; 改写package.json&#123; &quot;scripts&quot;: &#123; &quot;script-name&quot;: &quot;babel-node script.js&quot; &#125;&#125; 在以上代码中，使用babel-node替代node,这样script.js本身就不需进任何转码处理了。 1.6.4 babel-registerbabel-register改写了require命令，为它加上了一个钩子，此后每当用require加载.js、.jsx、.es、 和.es6文件时，就会先用Babel进行转码。 安装命令如下： 1npm install --save-dev babel-register 使用时，必须首先加载babel-register 12require(&quot;babel-register&quot;);require(&quot;index.js&quot;) 1.6.5 babel-core调用Babel的API对某些代码进行转码。 安装命令如下： 1npm install babel-core -save 例如： 123456789101112131415161718var babel &#x3D; require(&#39;babel-core&#39;)&#x2F;&#x2F; 字符串转码babel.transform(&#39;core()&#39;, options);&#x2F;&#x2F; &#x3D;&gt; &#123; code, map, ast&#125;&#x2F;&#x2F; 文件转码（异步）babel.transformFile(&#39;filename.js&#39;, options, function(err, result) &#123; result; &#x2F;&#x2F; &#x3D;&gt; &#123;code, map, ast&#125;&#125;)&#x2F;&#x2F; 文件转码（同步）babel.transformFileSync(&#39;filename.js&#39;, options);&#x2F;&#x2F; &#x3D;&gt; &#123;code, map, ast&#125;&#x2F;&#x2F; Babel AST转码babel.transformFormAst(ast, code, options);&#x2F;&#x2F; &#x3D;&gt; &#123;code, map, ast&#125; options是一个配置对象。下面是一个详细的例子： 1234567891011var es6Code &#x3D; &#39;let x &#x3D; n &#x3D;&gt; n + 1&#39;;var es5Code &#x3D; require(&#39;babel-core&#39;).transform(es6Code, &#123; presets: [&#39;latest&#39;]&#125;).code;&#x2F;&#x2F; 转码后：&#x2F;&#x2F; &quot;use strict&quot;; &#x2F;&#x2F; var x &#x3D; function x(n) &#123;&#x2F;&#x2F; return n + 1;&#x2F;&#x2F; &#125;; 1.6.6 babel-polyfillBabel默认只转化新的js句法（syntax), 而不转化新的API, 如Iterator、Generator、Set、Map、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（如Object.assign）都不会转码。如果想让这些对象或方法（API）运行，必须使用babel-polyfill为当前环境提供一个垫片。安装命令如下： 1npm install --save babel-polyfill 然后，在脚本头部加入如下代码： 123import &#39;babel-polyfill&#39;&#x2F;&#x2F; 或者require(&#39;bebel-polyfill&#39;) Babel默认不转码的API很多，详细查看文档。 1.6.7 浏览器环境","categories":[{"name":"ES6","slug":"ES6","permalink":"http://example.com/categories/ES6/"}],"tags":[{"name":"ES6 Web前端","slug":"ES6-Web前端","permalink":"http://example.com/tags/ES6-Web%E5%89%8D%E7%AB%AF/"}]},{"title":"Node.js路由","slug":"node.js路由","date":"2020-10-11T07:54:26.000Z","updated":"2020-10-22T08:24:32.464Z","comments":true,"path":"2020/10/11/node.js路由/","link":"","permalink":"http://example.com/2020/10/11/node.js%E8%B7%AF%E7%94%B1/","excerpt":"Node.js路由路由: Web服务器根据用户输入的不同url返回不同的页面。","text":"Node.js路由路由: Web服务器根据用户输入的不同url返回不同的页面。 例如登录页面login和注册页面register 123#默认端口都为80http:&#x2F;&#x2F;localhost:80&#x2F;loginhttp:&#x2F;&#x2F;localhost:80&#x2F;register 实现思路建立所需要的文件, index.js文件作为入口文件, router.js实现路由响应, server.js用来处理请求. file文件夹下就建立几个不同的页面, 展示路由跳转. 创建一个http服务器，用于监听用户输入的request参数, 获取request.url12345678&#x2F;&#x2F; server.jsconst http &#x3D; require(&quot;http&quot;);http.createServer(onRequest).listen(&#39;8888&#39;);function onRequest(req, res) &#123; &#x2F;&#x2F; onRequest处理用户请求 console.log(req.url);&#125; 解析url，得到具体的请求页面，也就是路由入口12345678910&#x2F;&#x2F; server.jsconst url &#x3D; require(&quot;url&quot;);function onRequest(req, res) &#123; console.log(req.url); let myUrl &#x3D; url.parse(req.url); console.log(myUrl);&#125; 根据url渲染不同页面123456789101112131415161718192021222324252627282930const http &#x3D; require(&quot;http&quot;);const fs &#x3D; require(&quot;fs&quot;);let Response &#x3D; function(res, filePath) &#123; fs.readFile(filePath, (err, data) &#x3D;&gt; &#123; if(err) &#123; res.writeHead(404, &#123; &quot;Content-Type&quot;: &quot;text&#x2F;html&quot; &#125;); res.end(&quot;error&quot;) &#125; else &#123; res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text&#x2F;html&quot; &#125;); res.end(data); &#125; &#125;)&#125;let router &#x3D; function(req, res) &#123; if(req.url &#x3D;&#x3D; &#39;&#x2F;index&#39; || req.url &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123; &#x2F;&#x2F;主页 index.index(res); &#125; else if(req.url &#x3D;&#x3D; &#39;&#x2F;poem&#39;) &#123; &#x2F;&#x2F; 古诗页面 Response(res, poem); &#125; else &#123; &#x2F;&#x2F; 不存在的页面 Response(res, error); &#125;&#125; 以上几步就能做一个简单的node路由demo了, 下面贴上完整的代码:12345&#x2F;&#x2F; 入口文件&#x2F;&#x2F; index.jsvar server &#x3D; require(&quot;.&#x2F;server&quot;);server.start(); 123456789101112131415161718192021222324252627282930313233343536373839404142&#x2F;&#x2F; router.js&#x2F;&#x2F; 需响应的文件路由const http &#x3D; require(&quot;http&quot;);&#x2F;&#x2F; 导入文件系统模块&#x2F;&#x2F; 所有的文件系统操作都具有同步的、回调的、以及基于 promise 的形式。const fs &#x3D; require(&quot;fs&quot;);const index &#x3D; require(&quot;.&#x2F;file&#x2F;index&quot;); &#x2F;&#x2F; 主页路由模块const error &#x3D; &quot;.&#x2F;file&#x2F;error404.html&quot;; &#x2F;&#x2F; 错误处理路由const poem &#x3D; &quot;.&#x2F;file&#x2F;poem.html&quot;; &#x2F;&#x2F; 古诗路由let Response &#x3D; function(res, filePath) &#123; fs.readFile(filePath, (err, data) &#x3D;&gt; &#123; if(err) &#123; res.writeHead(404, &#123; &quot;Content-Type&quot;: &quot;text&#x2F;html&quot; &#125;); res.end(&quot;error&quot;) &#125; else &#123; res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text&#x2F;html&quot; &#125;); res.end(data); &#125; &#125;)&#125;let router &#x3D; function(req, res) &#123; if(req.url &#x3D;&#x3D; &#39;&#x2F;index&#39; || req.url &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123; &#x2F;&#x2F;主页 index.index(res); &#125; else if(req.url &#x3D;&#x3D; &#39;&#x2F;poem&#39;) &#123; Response(res, poem); &#125; else &#123; Response(res, error); &#125;&#125;exports.router &#x3D; router; 123456789101112131415161718192021222324252627282930313233343536373839&#x2F;&#x2F; server.js&#x2F;&#x2F; 服务端的start函数, 用于开启一个web服务器&#x2F;&#x2F; 导入http模块，使用HTTP服务器和客户端&#x2F;&#x2F; Node中的HTTP API是非常底层的，&#x2F;&#x2F; 仅进行流处理和消息解析。它将消息解析为消息头和消息体，但不会解析具体的消息头或消息体const http &#x3D; require(&quot;http&quot;);&#x2F;&#x2F; 导入url模块，用于处理与解析 URL。&#x2F;&#x2F; URL字符串是结构化的字符串，包含多个含义不同的组成部分。解析后返回的是URL对象&#x2F;&#x2F; url 模块提供了两套 API 来处理 URL：一个是旧版本传统的 API，一个是实现了 WHATWG标准的新 API。const url &#x3D; require(&quot;url&quot;);const router &#x3D; require(&#39;.&#x2F;router&#39;)function start() &#123; function onRequest(req, res) &#123; if(req.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;favicon.ico&#39;) &#123; &#x2F;&#x2F; 浏览器默认会请求网站根目录的favicon.ico图标，如果网站根目录没有会产生 404。出于优化的考虑，要么就有这个图标，要么就禁止产生这个请求。 return ; &#125; console.log(&#39;End of line&#39;); console.log(req.url); let myUrl &#x3D; url.parse(req.url); console.log(myUrl); router.router(req, res) &#125; http.createServer(onRequest).listen(&#39;8888&#39;) console.log(&quot;Server is running at &quot; + &quot;http:&#x2F;&#x2F;localhost:8888&quot;);&#125;exports.start &#x3D; start;","categories":[{"name":"Node","slug":"Node","permalink":"http://example.com/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://example.com/tags/Node/"},{"name":"Web前端","slug":"Web前端","permalink":"http://example.com/tags/Web%E5%89%8D%E7%AB%AF/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-10-11T06:58:02.426Z","updated":"2020-10-22T08:06:31.314Z","comments":true,"path":"2020/10/11/hello-world/","link":"","permalink":"http://example.com/2020/10/11/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hello","slug":"Hello","permalink":"http://example.com/categories/Hello/"}],"tags":[{"name":"Hello","slug":"Hello","permalink":"http://example.com/tags/Hello/"}]}],"categories":[{"name":"ES6","slug":"ES6","permalink":"http://example.com/categories/ES6/"},{"name":"Node","slug":"Node","permalink":"http://example.com/categories/Node/"},{"name":"Hello","slug":"Hello","permalink":"http://example.com/categories/Hello/"}],"tags":[{"name":"ES6 Web前端","slug":"ES6-Web前端","permalink":"http://example.com/tags/ES6-Web%E5%89%8D%E7%AB%AF/"},{"name":"Node","slug":"Node","permalink":"http://example.com/tags/Node/"},{"name":"Web前端","slug":"Web前端","permalink":"http://example.com/tags/Web%E5%89%8D%E7%AB%AF/"},{"name":"Hello","slug":"Hello","permalink":"http://example.com/tags/Hello/"}]}